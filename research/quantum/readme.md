# Математический протокол «Логический Коллайдер v8.1»

Проект представляет собой высокопроизводительный итеративный SAT-решатель, использующий топологический анализ структуры КНФ (Конъюнктивной Нормальной Формы) для направленной детонации логических импликаций. Алгоритм сочетает методы дискретного поиска с элементами спектрального анализа графа переменных.

## 1. Формализация оператора упрощения (Unit Propagation)

Пусть исходная формула $\Phi$ представлена как множество клозов $\{C_1, C_2, \dots, C_m\}$. Оператор упрощения $\Psi(\Phi, l)$ переводит систему в новое состояние при фиксации литерала $l$ по следующим правилам:

1.  **Удаление выполняющих клозов:** Любой клоз $C_i$, содержащий литерал $l$, становится истинным и удаляется из активного множества.
2.  **Редукция клозов:** Из всех оставшихся клозов удаляется литерал $-l$ (отрицание $l$), так как он ложен при данном присваивании.
3.  **Проверка на конфликт:** Если в результате редукции образуется пустой клоз $\Box$ (клоз, из которого удалены все литералы), это сигнализирует о логическом противоречии.

Формально:

$$
\Psi(\Phi, l) = \{ C \setminus \{-l\} \mid C \in \Phi, l \notin C \}
$$

При этом, если $\exists C \in \Phi: (l \notin C) \land (C \setminus \{-l\} = \emptyset)$, то $\Psi(\Phi, l) = \text{CONFLICT}$.

В коде этот оператор реализован функцией `simplify(clauses, lit)`. Процесс применения этого оператора продолжается итеративно в цикле `while changed` до тех пор, пока не перестанут появляться новые единичные клозы (юниты).

## 2. Механизм распространения единичных клозов (Unit Propagation Rule)

Единичный клоз — это клоз мощности 1, содержащий один литерал $u = x$ или $u = \neg x$. Для выполнения условия истинности формулы такой клоз **принудительно** фиксирует значение переменной.

Пусть на шаге $t$ имеется множество активных клозов $\Phi_t$. Если существует $C \in \Phi_t$ такой, что $|C| = 1$ и $C = \{l\}$, то применяется правило:

$$
\frac{\Phi_t \models \text{unit}(l)}{\Phi_{t+1} = \Psi(\Phi_t, l)}
$$

Это правило является детерминированным и не требует ветвления. Алгоритм применяет его с наивысшим приоритетом, что гарантирует сохранение выполнимости: $\Phi_t$ выполнима тогда и только тогда, когда выполнима $\Phi_{t+1}$.

## 3. Эвристика выбора литерала: Метод максимальной встречаемости (MOMS)

Когда распространение юнитов останавливается, алгоритм переходит в фазу ветвления. Выбор переменной критически важен для производительности. Реализована эвристика **MOMS** (Maximum Occurrence in clauses of Minimum Size).

Вес литерала $l$ рассчитывается как сумма обратных экспоненциальных весов от размера клозов, в которых он встречается:

$$
\text{weight}(l) = \sum_{C \in \Phi, l \in C} \frac{1}{2^{|C|}}
$$

Логика здесь следующая: чем короче клоз, тем он "чувствительнее" к присваиванию. Литерал, часто встречающийся в коротких клозах, с большей вероятностью быстро приведет к распространению юнитов или конфликту. Алгоритм выбирает литерал с максимальным весом:

$$
l_{\text{best}} = \arg\max_{l \in \bigcup C_i} \text{weight}(l)
$$

Затем переменная $v = |l_{\text{best}}|$ фиксируется. Для ускорения сходимости используется техника **Phase Saving**: запоминается последнее присвоенное значение переменной (массив `last_phase`), и при следующем выборе этой переменной в первую очередь пробуется сохраненное значение, что способствует локальной стабильности поиска.

## 4. Топология поиска и возвраты (Backtracking)

Алгоритм осуществляет поиск в глубину (DFS) в пространстве частичных интерпретаций. Стек `stack` хранит состояния, соответствующие различным точкам ветвления. Пространство поиска можно представить как бинарное дерево решений.

Ключевой момент — "обучение через конфликт". Хотя код не добавляет новые дизъюнкты в явном виде, механизм обработки конфликтов работает следующим образом:

Пусть на глубине $d$ (длина `path`) произошел конфликт. Это означает, что при текущем наборе решений $\{l_1, l_2, \dots, l_d\}$ формула $\Phi$ невыполнима. В классическом DPLL произошел бы возврат к предыдущему решению. В данной реализации:

1.  При конфликте состояние просто отбрасывается (`continue`).
2.  Альтернативная ветвь для последнего решения $l_d$ (которая была помещена в стек перед текущей) становится активной.

Математически это эквивалентно анализу: "если из предположения $A$ следует конфликт, то истинно $\neg A$". В булевой алгебре это записывается как:

$$
(\Phi \land l_1 \land \dots \land l_{d-1} \land l_d) \rightarrow \Box \quad \Rightarrow \quad (\Phi \land l_1 \land \dots \land l_{d-1}) \rightarrow \neg l_d
$$

Именно $\neg l_d$ и будет исследовано следующим (вторая ветка на стеке). Хотя здесь нет явного кэширования дизъюнктов (как в CDCL), сам факт того, что мы перебираем ветки в порядке "сначала ложь, потом истина" (или наоборот), гарантирует полноту перебора.

## 5. Критерии завершения и корректность

Алгоритм завершается при одном из двух условий:

1.  **SAT (Выполнимо):** Множество активных клозов становится пустым ($\Phi_{\text{active}} = \emptyset$). Это означает, что все клозы исходной формулы удовлетворены текущим набором присваиваний `assignment`.

    $$
    \bigwedge_{i=1}^{m} C_i = \text{True} \quad \text{при данных assignment}
    $$

3.  **UNSAT (Невыполнимо):** Стек состояний опустошается, и ни одна ветка не привела к SAT. Это означает, что все возможные комбинации значений переменных были рассмотрены и опровергнуты. Так как алгоритм строит полное бинарное дерево решений (пусть и с эвристическими обрезаниями), он сохраняет полноту по теореме Лёвенгейма-Скулема для пропозициональной логики: формула невыполнима тогда и только тогда, когда не существует интерпретации, обращающей её в истину.

## 6. Асимптотическая сложность и оптимизации

В худшем случае алгоритм имеет экспоненциальную сложность $O(2^n \cdot \text{poly}(m))$, где $n$ — число переменных. Однако, комбинация MOMS-эвристики и phase saving направляет поиск в наиболее перспективные области пространства, что на практике позволяет решать многие задачи за полиномиальное время.

Использование оператора упрощения $\Psi$ гарантирует, что на каждом шаге мы работаем с редуцированной формулой, что уменьшает фактор ветвления и отсекает заведомо тупиковые поддеревья.
