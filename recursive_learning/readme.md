## Алгоритм «Матрёшка» 
###### Рекурсивная декомпозиция графа переменных для эффективного построения BDD в задачах 3-SAT

## 1. Введение
Построение бинарных диаграмм решений (BDD) для задач выполнимости булевых формул (SAT) в зоне фазового перехода ограничено проблемой экспоненциального роста размера диаграммы. Настоящая работа представляет алгоритм «Матрёшка», использующий структурные свойства графа переменных для итеративного сжатия пространства поиска.

## 2. Теоретические основания

### 2.1. Определения

Пусть F - булева формула в форме 3-КНФ, заданная на множестве переменных V. 

Граф переменных G=(V,E) содержит ребро {u,v}, если переменные u и v совместно входят хотя бы в один клоз.

##### Теорема 1 (Разбиение через вершинное покрытие):

Вершинное покрытие P⊆V графа G разделяет множество переменных на две части:
- Покрывающее множество (P): Переменные, обеспечивающие связи в графе.
- Независимое множество (Q=V\P): Переменные, между которыми отсутствуют ребра. По определению, для функции в форме 3-КНФ |Q|≥2.

##### Теорема 2 (Рекурсивная декомпозиция):

Множество P может быть рекурсивно разбито на пары (Pi, Qi), образуя иерархическую структуру уровней (матрёшку).

#### 2.2. Классификация ограничений (Клозов)

Для каждого уровня декомпозиции Li клозы C разделяются на:
- Мосты (Cbridge) - клозы, содержащие хотя бы одну переменную из Qi. Формально: c∈Cbridge⇔var(c)⋂Qi≠∅.
- Остаточные клозы (Cres) - клозы, состоящие только из переменных покрывающего множества Pi.

### 3. Описание алгоритма
Алгоритм состоит из двух фаз: декомпозиции (Top-Down) и итеративного обучения (Bottom-Up).

#### 3.1. Фаза декомпозиции
Формула F разбивается на n уровней. На каждом уровне i вычисляется:
Vi→{Pi,Qi}

Статистические данные для случайных задач (например, uf100) показывают, что в зоне фазового перехода размер сепаратора Q остается стабильно малым (|Q|≈8..14), что позволяет эффективно применять элиминацию.

#### 3.2. Фаза обучения (Bottom-Up Training)
Процесс начинается с самого глубокого уровня Ln и движется к L0.
  1. Интеграция знаний: BDD уровня i принимает диаграмму от уровня i+1, содержащую логические зависимости переменных Pi.
  2. Наложение мостов: В BDD добавляются ограничения из Cbridge, связывающие Qi и Pi.
  3. Элиминация независимого множества: Выполняется операция экзистенциальной квантификации для всех переменных q∈Qi: BDDnew = ∃Qi.(BDDold∧Cbridge)
  4. Liveness Optimization (Оптимизация жизненного цикла):
    - Переменная v∈Pi элиминируется из BDD, если она не входит ни в один клоз на уровнях j<i. Это предотвращает избыточную размерность диаграммы.

### 4. Оптимизация и производительность
Применение элиминации «мертвых» переменных из P и использование малых сепараторов Q позволяет удерживать размер BDD в рамках линейного или полиномиального роста относительно |V|  для определенных классов задач.

Наблюдаемые статистические данные для uf100 (выборка из 1000 экземпляров)
| Уровень |  |  | Мосты |
| :--- | :--- | :--- | :--- |
| 0 | 69.9 | 13.9 | 151.9 |
| 1 | 57.7 | 12.3 | 136.6 |
| 2 | 46.6 | 11.0 | 116.7 |
| 3 | 36.9 | 9.8 | 94.6 |
| 4 | 28.2 | 8.6 | 73.3 |
| 5 | 20.8 | 7.5 | 53.3 |

### 5. Заключение
Метод «Матрёшка» переносит вычислительную сложность с глобального построения BDD на локальные операции элиминации переменных в малых группах Q. Основным фактором успеха является своевременное удаление переменных, потерявших актуальность для последующих уровней графа.


### 6. Математический анализ сложности элиминации
Основная сложность алгоритма «Матрёшка» сосредоточена в операции экзистенциальной квантификации ∃x.F. 

В этом разделе анализируется влияние параметров декомпозиции на размер BDD и временные затраты.
#### 6.1. Сложность операции элиминации в BDD
Для BDD-представления функции f, операция ∃x.f вычисляется как: ∃x.f = f(x=0) ∨ f(x=1), где f(x=v) - ограничение функции (кофактор).

Теоретическая оценка: В худшем случае размер результирующего BDD после элиминации одной переменной может вырасти квадратично: |BDDnew| = O(|BdDDold|\^2)

Однако, благодаря структуре независимого множества Q, переменные внутри него не связаны друг с другом напрямую. Это позволяет выполнять элиминацию Q как серию независимых операций, что на практике дает гораздо меньший прирост узлов, чем в общем случае.

#### 6.2. Влияние сепаратора Q на ширину диаграммы
Размер BDD напрямую зависит от ширины сечения (cut width) графа переменных при заданном порядке.
- Пусть w — ширина сечения на уровне i.
- Количество узлов в BDD ограничено величиной 2\^w.
В методе «Матрёшка» выбор Q как независимого множества минимизирует количество новых логических связей (резольвент), возникающих между переменными из P при удалении Q.

Если |Q| ограничено константой k, то сложность обработки одного уровня составляет O(2\^k·poly(|P|)). 

Согласно эмпирическим данным для uf100, k≈13, что дает 2\^13=8192 состояний — величина, легко обрабатываемая современными BDD-менеджерами.

#### 6.3. Эффект Liveness-оптимизации (удаление «мертвых» переменных)
Ключевая проблема, увеличивающая сложность, описывается законом накопления зависимостей.

Без удаления переменных из P, размер BDD на уровне i определяется как Size(BDDi)=exp(|V|-∑|Qj|), при j=i..n

При включении Liveness Analysis, из BDD удаляются переменные v, для которых: ∀c∈{Cbridge(0..i-1)}:v∉var(c)

Это эффективно снижает «активную» ширину BDD. Если Vactive - множество переменных, которые одновременно присутствуют в мостах текущего и будущих уровней, то размер BDD ограничивается 2\^|Vactive|. Оптимизация гарантирует, что |Vactive|≤|V|, что переводит сложность из глобально-экспоненциальной в локально-экспоненциальную.

#### 6.4. Проблема промежуточного взрыва (Intermediate Explosion)
Зависание на этапе добавления мостов Cbridge объясняется тем, что при выполнении операции конъюнкции BDD^ck промежуточный размер структуры может кратно превышать финальный.

Условие стабильности: Для успешного прохождения уровня необходимо выполнение условия: max(size(BDD(i+1)∧Cbridge(i)) < MemoryLimit

Именно здесь Liveness-оптимизация играет решающую роль: уменьшая BDD(i+1) за счет удаления ненужных переменных P на предыдущем шаге, мы создаем «запас прочности» по памяти для добавления новых клозов на текущем шаге.
